{
    "iot.4diac": {
        "description": "<p>4DIAC in its current form has been started 2007 as open source project fostering the further development of IEC 61499 for its use in distributed IPMCS and further distribute research results from the original contributors. From the beginning it provided everything necessary to program and execute distributed IPMCS.</p>\r\n<p>4DIAC became one of the main sources for IEC 61499-based research and development (see for example the <a href=\"http://www.fordiac.org/52.0.html\">4DIAC Users&#39; Workshop</a> series). It has been successfully applied in a number of industrial systems, like <a href=\"http://www.fordiac.org/30.0.html\">manufacturing systems</a>, <a href=\"http://www.fordiac.org/28.0.html\">logistics</a>, <a href=\"http://www.fordiac.org/48.0.html\">power and energy applications</a>, <a href=\"http://www.fordiac.org/31.0.html\">robotics</a>, or building automation.</p>\r\n<p>A screenshot of the 4DIAC-IDE is presented in the following figure:</p>\r\n<p><img alt=\"4DIAC overview\" src=\"/sites/default/files/4diac.jpg\" style=\"width: 480px; height: 333px;\" /></p>",
        "id": "iot.4diac",
        "logo": "https://projects.eclipse.org/sites/default/files/4diac.png",
        "name": "4DIAC - Framework for Distributed Industrial Automation and Control",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.4diac",
        "website": "http://www.eclipse.org/4diac"
    },
    "iot.californium": {
        "description": "<p>Eclipse Californium (Cf) is an open source implementation of the Constrained Application Protocol (CoAP). It is written in Java and targets unconstrained environments such as back-end service infrastructures (e.g., proxies, resource directories, or cloud services) and less constrained environments such as embedded devices running Linux (e.g., smart home/factory controllers or cellular gateways).</p>",
        "id": "iot.californium",
        "logo": "https://projects.eclipse.org/sites/default/files/Cf_128.png",
        "name": "Californium (Cf) CoAP Framework",
        "provisioned": true,
        "state": "Regular",
        "url": "https://projects.eclipse.org/projects/technology.californium",
        "website": "https://www.eclipse.org/californium/"
    },
    "iot.concierge": {
        "description": "<p>Concierge is a small-footprint implementation of the OSGi Core Specifications R5 standard optimized for mobile and embedded devices.</p>",
        "id": "iot.concierge",
        "logo": "https://projects.eclipse.org/sites/default/files/logo_0.png",
        "name": "Concierge",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/rt.concierge",
        "website": null
    },
    "iot.eclipsescada": {
        "description": "<p>SCADA (supervisory control and data acquisition) is a type of industrial control system (ICS). Industrial control systems are computer controlled systems that monitor and control industrial processes that exist in the physical world. SCADA systems historically distinguish themselves from other ICS systems by being large scale processes that can include multiple sites, and large distances.</p>\r\n<p>Simply speaking the primary target of Eclipse SCADA is a way to connect different industrial devices to a common communication system and post-process as well as visualize the data to operating personnel.</p>\r\n<p>Since this scheme will also work with non-industrial devices and devices do become more complex and tend to become software solutions themselves the term &ldquo;device&rdquo; should be more considered as an &ldquo;other system&rdquo;.</p>\r\n<p>The idea of a SCADA system is to provide mostly scalar values instead of complex data structures. Where necessary data structures are split up into multiple scalar values. This is done in order to process the data more quickly and allow common processing of data.</p>\r\n<p>For example a meteo station is providing current weather information. It can provide temperature and solar radiation. These are two floating point values which are processed independently. Still the same alarming schema (high level alarm) can be applied to both values. The values can both be assigned a quality/alarm information (alarm state) which can then be shown using the same user interface element and the same visualization scheme (alarm is displayed with red background). This way many different scalar values can be processed exactly the same way.</p>",
        "id": "iot.eclipsescada",
        "logo": "https://projects.eclipse.org/sites/default/files/LOGO_neoSCADA_151207_72.png",
        "name": "Eclipse NeoSCADA",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.eclipsescada",
        "website": "http://www.eclipse.org/eclipsescada/"
    },
    "iot.edje": {
        "description": "<p wrap=\"\">The edge devices connected to the Cloud that constitute the Internet of Things (IoT) require support for building blocks, standards and frameworks like those provided by the Eclipse Foundation projects: Californium, Paho, Leshan, Kura, Mihini, etc.<br />\r\n\tBecause of the large deployment of Java technology in the Cloud, on the PC, mobile and server sides, most projects above are implemented in Java technology.</p>\r\n<!--break-->\r\n<p>Deploying these technologies on embedded devices requires a scalable IoT software platform that can support the hardware foundations of the IoT: microcontrollers (MCU). MCU delivered by companies like STMicroelectronics, NXP+Freescale, Renesas, Atmel, Microchip, etc. are small low-cost low-power 32-bit processors designed for running software in resource-constraint environments: low memory (typically KB), flash (typically MB) and frequency (typically MHz).<br />\r\n\t<br />\r\n\tThe goal of the Edje project is to define a standard high-level Java API called Hardware Abstraction Layer (HAL) for accessing hardware features delivered by microcontrollers such as GPIO, DAC, ADC, PWM, MEMS, UART, CAN, Network, LCD, etc. that can directly connect to native libraries, drivers and board support packages provided by silicon vendors with their evaluation kits.<br />\r\n\t<br />\r\n\tTo achieve this goal, the Edje project also defines the minimal set of API required for delivering IoT services, leveraging largely-deployed technologies, and meeting performance and memory constraints of IoT embedded devices. Edje defines the Edje Device Configuration (EDC). Care has been taken to make the EDC a proper subset of the different Java runtime environments found in Android, J2SE, J2ME, OSGi Minimum and others. This project presents the packages and API that constitute the core of EDC, defines the minimal foundation that iot.eclipse.org projects can rely on, and still compatible with economical constraints of the IoT: footprint. EDC covers the standard packages part of the Java core language (java.lang, java.io, &hellip;).</p>",
        "id": "iot.edje",
        "logo": "https://projects.eclipse.org/sites/default/files/edje_2.png",
        "name": "Edje",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.edje",
        "website": null
    },
    "iot.hawkbit": {
        "description": "<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">Project hawkBit aims to create a <strong>domain independent back end</strong> solution for rolling out <strong>software updates</strong> to constrained edge <strong>devices</strong> as well as more powerful controllers and gateways connected to IP based networking infrastructure. Devices can be connected to the hawkBit server either directly through an optimized interface or indirectly through federated&nbsp;device management servers.</p>\r\n<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\"><img alt=\"\" src=\"/sites/default/files/pictures/hawkBit.png\" style=\"width: 700px; height: 348px;\" /></p>\r\n<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">hawkBit is device and communication channel neutral by means of supporting:</p>\r\n<ul style=\"margin: 10px 0px 0px 25px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">\r\n\t<li>\r\n\t\t<strong>Software</strong>&nbsp;and&nbsp;Operating system&nbsp;updates for&nbsp;M2M gateways&nbsp;(typically but not necessarily running Linux)&nbsp;and</li>\r\n\t<li>\r\n\t\t<strong>Firmware</strong>&nbsp;updates for&nbsp;embedded&nbsp;devices</li>\r\n</ul>\r\n<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">both for</p>\r\n<ul style=\"margin: 10px 0px 0px 25px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">\r\n\t<li>\r\n\t\t<strong>cable</strong>&nbsp;or</li>\r\n\t<li>\r\n\t\t<strong>over the air</strong>&nbsp;(OTA) connected devices</li>\r\n</ul>\r\n<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">Features at a glance:</p>\r\n<ul style=\"margin: 10px 0px 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\">\r\n\t<li>\r\n\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">A device and software repository.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">Artifact content delivery.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">Software update and roll out management.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">Reporting and monitoring.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">Interfaces:</p>\r\n\t\t<ul style=\"margin: 0px; list-style-type: disc;\">\r\n\t\t\t<li>\r\n\t\t\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">for direct device control.</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">for IoT solutions or applications to manage the repository and the roll outs.</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">for device management federation (i.e. indirect device control)</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p style=\"margin: 0px; padding: 0px; background-color: transparent;\">and a user interface to operators to manage and run the roll outs.</p>\r\n\t\t\t</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>\r\n<p style=\"margin: 10px 0px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Arial, sans-serif; font-size: 14px; line-height: 20px;\"><img alt=\"\" src=\"/sites/default/files/pictures/SP_Intro.png\" style=\"width: 700px; height: 492px;\" /></p>",
        "id": "iot.hawkbit",
        "logo": "https://projects.eclipse.org/sites/default/files/hawkbit-200px.png",
        "name": "hawkBit",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.hawkbit",
        "website": null
    },
    "iot.hono": {
        "description": "<div>\r\n\tConnectivity is at the heart of IoT solutions. Devices (things) need to be connected to a back end component where the data and functionality of the devices is leveraged to provide some higher level business value. IoT solution developers can pick from a wide array of existing (open source) technology to implement a device connectivity &amp; management layer for the particular type of devices at hand. While this is often fun for the developers to do, the resulting solutions are often silo applications lacking the ability to scale horizontally with the number of devices connected and the number of back end components consuming the device data and functionality.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tThe Eclipse IoT Working Group has therefore discussed &nbsp;a more generic, cloud-based IoT platform architecture which better supports the implementation of IoT solutions without requiring developers to solve some of the recurring (technical) challenges over and over again. The diagram below provides an overview of the IoT Server Platform as discussed in the working group.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\t<img alt=\"\" src=\"https://wiki.eclipse.org/images/6/6f/IoT_Server_Building_Blocks.jpg\" style=\"width: 100%; float: left;\" /></div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tThe diagram shows how devices in the field are connected to a cloud-based back end either via a Field Gateway (e.g. something like Eclipse Kura) or directly to so-called <em>Protocol Adapters</em>. The Protocol Adapters&#39; responsibility is abstracting communication protocols as well as providing location transparency of devices to the other back end components. The devices upload (sensor) data to the back end while the functions/services they expose can be invoked from the back end. These two directions of information flow can be characterized as follows:</div>\r\n<ul>\r\n\t<li>\r\n\t\tTelemetry<br />\r\n\t\t<strong>Data</strong> flowing upstream (left to right) from devices to the back end to a consumer like a Business Application or the Device Management component usually <strong>consists of</strong>&nbsp;a small set of discrete values like <strong>sensor readings</strong> or status property values. In most cases these messages are one-way only, i.e. devices sending this kind of data usually do not expect a reply from the back end.</li>\r\n\t<li>\r\n\t\tCommand &amp; Control<br />\r\n\t\t<strong>Messages</strong> flowing downstream (right to left) from back end components like Business Applications often <strong>represent invocations of services</strong> or functionality provided by connected devices, e.g. instructions to download and apply a firmware update, setting configuration parameters or querying the current reading of a sensor. In most cases a reply to the sent message is expected by the back end component.</li>\r\n</ul>\r\n<div>\r\n\tIt seems reasonable to assume that the number of messages flowing upstream (Telemetry) will be orders of magnitude larger than the number of messages flowing downstream (Command &amp; Control). The aggregated overall number of messages flowing upstream is expected to be in the range of several hundred thousand to millions per second. Note that in this architecture the same (cloud-based) infrastructure is shared by multiple solutions.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tThe IoT Connector component provides the central link between the device-facing Protocol Adapters, additional re-usable back end components, e.g. Device Management or Software Provisioning, and last but not least the IoT solutions leveraging the devices&#39; data and services. Solution developers can use the IoT Connector to uniformly and transparently interact with all kinds of devices without the need for caring about the particular communication protocol(s) the devices use. Multiple solutions can use the same IoT Connector instance <strong>running in a shared cloud environment</strong> in order to <strong>share the data and functionality of all connected devices</strong>. The IoT Connector ensures that only those components can consume data and control devices that have been granted authorization by the device owner. In this regard the IoT Connector can be considered an IoT specific message broker targeted at cloud deployment scenarios.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\t<div>\r\n\t\tThe IoT Connector component needs to fulfill a set of&nbsp;<strong>non-functional requirements</strong>, in particular regarding&nbsp;<strong>horizontal scalability</strong>, that are specific to both the deployment environment (cloud) and the intended architectural platform characteristics (as opposed to embedding a connectivity layer into applications individually). However, these requirements are not specific to any particular application domain. From a technical point of view it makes no difference if a sensor reading received via a LWM2M protocol adapter represents a temperature or the relative humidity. In both cases the IoT Connector&#39;s responsibility is to forward the messages containing the values to (potentially multiple) authorized consumers without introducing too much latency.</div>\r\n\t<div>\r\n\t\t&nbsp;</div>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\t<strong>Features at a glance</strong></div>\r\n<ul>\r\n\t<li>\r\n\t\tSecure message dispatching</li>\r\n\t<li>\r\n\t\tSupport for different message exchange patterns</li>\r\n\t<li>\r\n\t\tUsed for cloud service federation</li>\r\n\t<li>\r\n\t\tProvides interfaces to support implementation of protocol adaptors which allow:\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tSending telemetry data</li>\r\n\t\t\t<li>\r\n\t\t\t\tReceiving device control messages (from applications/solutions)</li>\r\n\t\t\t<li>\r\n\t\t\t\tRegistering authorized consumers of telemetry data received from connected devices</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>",
        "id": "iot.hono",
        "logo": "https://projects.eclipse.org/sites/default/files/HONO-Logo_Bild-Wort_quadrat-w-200x180px.png",
        "name": "Hono",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.hono",
        "website": null
    },
    "iot.iofog": {
        "description": "<p>The Eclipse ioFog set of technologies is a fog computing layer that can be installed on any hardware running Linux. Once installed, it provides a universal runtime for microservices to run on the edge. In addition to a common runtime, ioFog also provides a set of useful services including a message bus, dynamic configuration of the microservices, and remote debugging.</p>\r\n<!--break-->\r\n<p>Automated interconnection of ioFog instances is provided by the ComSat component. This relieves developers from writing code just to move data from one place to another.</p>\r\n<p>Orchestration and management of microservices (the edge software) is provided by the ioAuthoring application and the ioFog instances receive their instructions through the fabric controller.</p>\r\n<p>Working together, these components provide a full set of technologies for building and running IoT software the executes wherever the developer chooses.</p>\r\n<p>&nbsp;</p>\r\n<p>In greater detail, the fog computing layer is comprised of the following:</p>\r\n<p>1. A fog computing software agent that runs on various operating systems and provides a universal runtime for IoT microservices. This is called &quot;ioFog&quot;.<br />\r\n\t&nbsp;</p>\r\n<div>\r\n\t2. A fog computing node controller that runs on popular Linux distributions and gives dynamic instruction to the ioFog instances. It has an API that allows for various tooling to be built for controlling the fog computing fabric. This is called &quot;Fabric Controller&quot;.<br />\r\n\t&nbsp;</div>\r\n<div>\r\n\t3. An internetworking utility that runs on popular Linux distributions and provides a way for ioFog instances to interconnect, even through private network layers and firewalls. This is called &quot;ComSat&quot;.<br />\r\n\t&nbsp;</div>\r\n<div>\r\n\t4. A design-time interface for creating, saving, editing, and deploying microservices schemas that are called &quot;tracks&quot;. It runs on popular Linux distributions and uses the Fabric Controller API to do its work. This is called &quot;ioAuthoring&quot;.<br />\r\n\t&nbsp;</div>\r\n<div>\r\n\t5. Software Development Kits (SDKs) in multiple programming languages that provide developers with the convenience of programming against objects instead of using the native REST API that exists within the ioFog.<br />\r\n\t&nbsp;</div>\r\n<p>6. A local software development tool that mimics the fog computing runtime and gives developers a way to test their code against simulated situations before making the effort to package their code as a microservice. This is called &quot;Test Message Generator&quot;.</p>\r\n<p class=\"rtecenter\"><img alt=\"The ioFabric component architecture\" src=\"http://iotracks.com/images/Component_Diagram.png\" style=\"width: 487px; height: 646px;\" /></p>",
        "id": "iot.iofog",
        "logo": null,
        "name": "ioFog",
        "provisioned": false,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.iofog",
        "website": null
    },
    "iot.kapua": {
        "description": "<p>The following diagram provides a functional architecture of the Eclipse Kapua project.</p>\r\n<p><img alt=\"\" src=\"https://eth-public.s3.amazonaws.com/EverywareCloudArch.png\" style=\"width: 640px; height: 317px;\" /></p>\r\n<h2>\r\n\tDevice Connectivity</h2>\r\n<p>The connectivity of the devices is managed through a multi-protocol message broker. In the initial contribution, the protocol for the device connectivity will be the IoT protocol MQTT. The broker supports other protocols including AMQP and WebSockets for application integration.</p>\r\n<p>The device connectivity module is responsible to authenticate connections, enforce the appropriate authorization &ndash; for example in the topic namespace &ndash; and maintain a Device Registry. The Device Registry stores the device profile, the device connection status and the device connection log. It also enables device organization through custom attributes and tags.</p>\r\n<h2>\r\n\tMessage Routing</h2>\r\n<p>The stream of data published by the devices may have different consumers. Certain messages, like command and control messages, are meant to be consumed by the Device Management component; other messages, like the telemetry data are meant to be archived in the IoT Platform or re-directed to other systems. The Message Routing component allows for flexible handling of message streams avoiding hard coded behaviors through configurable massage routes.</p>\r\n<h2>\r\n\tDevice Management</h2>\r\n<p>Through the Device Management component, the IoT platform can perform remote operations on the connected devices. The IoT platform exposes an open contract towards the devices being managed with no assumption on the device software stack. In the initial contribution, the device management contract is based on an open application protocol over MQTT. Such protocol is already implemented by the Eclipse Kura project. With such protocol, the IoT platform can:</p>\r\n<ul>\r\n\t<li>\r\n\t\tIntrospect and manage the device configuration</li>\r\n\t<li>\r\n\t\tManage the device services including service start and stop operations</li>\r\n\t<li>\r\n\t\tManage the device applications including application install, update, and remove</li>\r\n\t<li>\r\n\t\tExecute remote OS commands on the device</li>\r\n\t<li>\r\n\t\tGet and set device attributes and resources</li>\r\n\t<li>\r\n\t\tProvision initial configuration of the devices</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<p>In its evolution and future community contributions, Eclipse Kapua may adopt additional device management protocols like the emerging LWM2M standard</p>\r\n<h2>\r\n\tData Management</h2>\r\n<p>Eclipse Kapua can archive the telemetry data sent by the devices into a persistent storage for application retrieval. A reference message payload is defined which allows for a timestamp, a geo position, strongly typed message headers and an opaque message body. The chosen encoding is based on an open Google Protocol Buffers grammar.</p>\r\n<p>In the initial contribution, a NoSQL data storage is used to allow for a flexible indexing of the telemetry messages. Incoming messages are stored and indexed by timestamp, topic, and originating asset. The NoSQL storage allows for indexing of the message headers.</p>\r\n<p>Data Management also keeps a Data Registry which maintains the topics and the metrics that received incoming traffic.</p>\r\n<p>&nbsp;</p>\r\n<h2>\r\n\tSecurity</h2>\r\n<p>&nbsp;</p>\r\n<p>A foundation layer maintains the security aspects of the IoT platform like the management of tenants, accounts and users. The account model supports a hierarchical access control structure. Following Role Based Access Control (RBAC), user identities can be defined and associated with one or more permissions guaranteeing the principle of &quot;least privilege&quot;. Devices connect to the platform using the credentials of one of these user identities or through SSL authentication.&nbsp;</p>\r\n<h2>\r\n\tApplication Integration</h2>\r\n<p>For integration with existing applications, Eclipse Kapua offers modern Web Services API based on Representational State Transfer (REST). The REST API exposes all the platform functionality, including device management and data management. The REST API also offers a &quot;bridge&quot; to the MQTT broker enabling the routing of commands from applications to devices without a specific connection to the message broker. Technologies such as REST/Comet/WebSockets are included allowing real-time display of data published by the devices in web pages and mobile dashboards.&nbsp;</p>\r\n<h2>\r\n\tAdministration Console</h2>\r\n<p>Eclipse Kapua features a web-based administration Console to perform all device and data management operations. A screenshot of the administration Console is shown below.</p>\r\n<p><img alt=\"\" src=\"https://eth-public.s3.amazonaws.com/EverywareCloudConsoleScreenshot.png\" style=\"width: 600px; height: 333px;\" /></p>",
        "id": "iot.kapua",
        "logo": null,
        "name": "Eclipse Kapua",
        "provisioned": false,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.kapua",
        "website": null
    },
    "iot.krikkit": {
        "description": "<p>The Krikkit architecture is a publish/subscribe mechanism where rules/policies are registered on edge routers/gateways that have visibility into and communicate with sensors.&nbsp;</p>",
        "id": "iot.krikkit",
        "logo": null,
        "name": "Krikkit",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.krikkit",
        "website": null
    },
    "iot.kura": {
        "description": "<p>Kura offers a Java/OSGi-based container for M2M applications running in service gateways. Kura provides or, when available, aggregates open source implementations for the most common services needed by M2M applications. Kura components are designed as configurable OSGi Declarative Service exposing service API and raising events. While several Kura components are in pure Java, others are invoked through JNI and have a dependency on the Linux operating system.</p>",
        "id": "iot.kura",
        "logo": "https://projects.eclipse.org/sites/default/files/kura_logo_small.png",
        "name": "Kura",
        "provisioned": true,
        "state": "Regular",
        "url": "https://projects.eclipse.org/projects/technology.kura",
        "website": "https://www.eclipse.org/kura/"
    },
    "iot.leshan": {
        "description": "<p>Leshan is an OMA Lightweight M2M (LWM2M) implementation in Java.</p>\r\n<!--break-->\r\n<p>Eclipse Leshan relies on the <a href=\"https://projects.eclipse.org/projects/iot.californium\" target=\"_blank\">Eclipse IoT Californium</a> project for the CoAP and DTLS implementation. It is tested against the LWM2M C client provided by the <a href=\"https://projects.eclipse.org/projects/iot.wakaama\" target=\"_blank\">Eclipse IoT Wakaama</a> project.</p>",
        "id": "iot.leshan",
        "logo": "https://projects.eclipse.org/sites/default/files/leshan.png",
        "name": "Leshan",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.leshan",
        "website": "https://eclipse.org/leshan"
    },
    "iot.milo": {
        "description": "<p>OPC Unified Architecture is an interoperability standard that enables the secure and reliable exchange of industrial automation data while remaining cross-platform and vendor neutral. The specification, currently version 1.03, is developed and maintained by the OPC Foundation with the guidance of individual software developers, industry vendors, and end-users. It defines the interface between Clients and Servers, including access to real-time data, monitoring of alarms and events, historical data access, and data modeling.</p>",
        "id": "iot.milo",
        "logo": null,
        "name": "Milo",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.milo",
        "website": null
    },
    "iot.mosquitto": {
        "description": "<p>Eclipse Mosquitto provides a lightweight server implementation of the MQTT protocol that is suitable for all situations from full power machines to embedded and low power machines. Sensors and actuators, which are often the sources and destinations of MQTT messages, can be very small and lacking in power. This also applies to the embedded machines to which they are connected, which is where Mosquitto could be run.</p>",
        "id": "iot.mosquitto",
        "logo": "https://projects.eclipse.org/sites/default/files/mosquitto-200px.png",
        "name": "Mosquitto",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.mosquitto",
        "website": "https://eclipse.org/mosquitto"
    },
    "iot.om2m": {
        "description": "<p>The OM2M project is an open source implementation of the ETSI M2M standard. It provides a framework for developing services independently of the underlying network and aims to facilitate deployment of vertical applications and heterogeneous devices.&nbsp;</p>",
        "id": "iot.om2m",
        "logo": "https://projects.eclipse.org/sites/default/files/OM2M_logo.png",
        "name": "OM2M",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.om2m",
        "website": "http://www.eclipse.org/om2m"
    },
    "iot.paho": {
        "description": "<p>The Paho project provides reliable open-source implementations of open and standard messaging protocols aimed at new, existing, and emerging applications for Machine-to-Machine (M2M) and Internet of Things (IoT).</p>\r\n<p>Paho reflects the inherent physical and cost constraints of device connectivity. Its objectives include effective levels of decoupling between devices and applications, designed to keep markets open and encourage the rapid growth of scalable Web and Enterprise middleware and applications. Paho contains <a href=\"http://mqtt.org\">MQTT</a> publish/subscribe client implementations for use on embedded platforms, along with corresponding server support as determined by the community.</p>",
        "id": "iot.paho",
        "logo": "https://projects.eclipse.org/sites/default/files/paho-logo-200.png",
        "name": "Paho",
        "provisioned": true,
        "state": "Regular",
        "url": "https://projects.eclipse.org/projects/technology.paho",
        "website": "http://www.eclipse.org/paho/"
    },
    "iot.paho.incubator": {
        "description": "<p>A permanent incubator for Paho.</p>\r\n<p>A permanent incubator is a project that is intended to perpetually remain in the&nbsp;<a href=\"https://www.eclipse.org/projects/dev_process/development_process.php#6_2_3_Incubation\">incubation</a>&nbsp;phase. Permanent incubators are an excellent place to innovate, test new ideas, grow functionality that may one day be moved into another project, and develop new committers.</p>\r\n<p>Permanent incubator projects never have releases; they cannot participate in the annual simultaneous release. Permanent incubators may have builds, and downloads. They conform to the standard incubation branding requirements and are subject to the IP due diligence rules outlined for incubating projects. Permanent incubators do not graduate.</p>",
        "id": "iot.paho.incubator",
        "logo": "https://projects.eclipse.org/sites/default/files/paho-logo-200_0.png",
        "name": "Paho Incubator",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.paho.incubator",
        "website": null
    },
    "iot.ponte": {
        "description": "<p>Ponte provides reusable solutions for bridging M2M protocols.</p>",
        "id": "iot.ponte",
        "logo": "https://projects.eclipse.org/sites/default/files/logo-banner-white_0.png",
        "name": "Ponte",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.ponte",
        "website": "http://eclipse.org/ponte"
    },
    "iot.risev2g": {
        "description": "<h3>\r\n\tAbout RISE V2G</h3>\r\n<div>\r\n\tRISE V2G is a <strong>R</strong>eference <strong>I</strong>mplementation <strong>S</strong>upporting the <strong>E</strong>volution of the <strong>V</strong>ehicle-<strong>2</strong>-<strong>G</strong>rid communication interface ISO/IEC 15118.</div>\r\n<div>\r\n\tThe international standard ISO/IEC 15118, entitled &quot;Road vehicles - Vehicle to grid communication interface&quot;, defines a digital IP-based communication interface between an electric vehicle (EV) and a charging station (named Electric Vehicle Supply Equipment - EVSE). It allows for a user-friendly &quot;plug-and-charge&quot; mechanism for authentication, authorisation, billing, and flexible load control based on a wide set of information exchanged between the EV and EVSE.</div>\r\n<div>\r\n\tA rise in the wide application of this standard is essential for reaching the goal of integrating EVs as flexible energy storage devices into a smart grid.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<!--break-->\r\n<h3>\r\n\tMission Statement</h3>\r\n<p>The RISE V2G project shall serve as an open source standard-compliant reference implementation and documentation. As such, the objective is to provide a test platform for interoperability testing and to offer an information resource for interested parties. The adoption of a new technology heavily depends on the interoperability of its various implementations. The more tests conducted, the more stable and reliable the developed solution will be.</p>\r\n<p>As the ISO/IEC 15118 consists of eight documment parts - with part 1 to 3 defining use cases and requirements for conductive charging, parts 4 and 5 dealing with conformance tests, and parts 6 to 8 specifying use cases and requirements for inductive charging - the RISE V2G project shall evolve to cover all aspects of conductive and inductive charging from the physical layer up to the application layer. However, it requires a lot of work to be done to fulfil this endeavor.<br />\r\n\tYour assistance would therefore be very appreciated, be it by testing this reference implementation against your own solution - this way uncovering possible bugs or making code optimisation suggestions - or by providing an implementation for yet missing parts.</p>\r\n<p>&nbsp;</p>\r\n<h3>\r\n\tScope and current status</h3>\r\n<p>As this standard describes a client/server-based protocol with the EV being the client and the EVSE being the server, this reference implementation covers both entities. The charging process can be authenticated and authorised via a so-called plug-and-charge mechanism (PnC) or via external identification means (EIM) such as an RFID card. Furthermore, there are several message sets defined for AC (alternating current) and DC (direct current) charging.</p>\r\n<p>This project covers all defined message sets and identification means.&nbsp;It currently focuses on the implementation of part 2 (<a href=\"http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=55366\" target=\"_blank\">ISO/IEC 15118-2</a>) of this standard defining the protocol requirements from the network up to the application layer (layer 3 to 7 of the ISO/OSI layer model) for the conductive charging scenario.</p>\r\n<p>This version provides a full implementation of this part including cryptographic functionality to enable TLS communication and XML signatures. The only feature not implemented is the OCSP (Online Certificate Status Protocol). Further testing is required by third parties to assure the correct implementation of all requirements listed in ISO/IEC 15118-2.</p>\r\n<div>\r\n\tRISE V2G allows you to create an EVCC instance acting as the client sending request messages related to the chosen charging scenario as well as an SECC instance acting as the server which is responding to those requests. EVCC stands for Electric Vehicle Communication Controller (inside the EV) whereas SECC is short for Supply Equipment Communication Controller (inside the EVSE).</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tThe current status of the project consists of three subprojects which implement the conductive charging scenario:</div>\r\n<ul>\r\n\t<li>\r\n\t\tthe EVCC project covering its state machine and request messages</li>\r\n\t<li>\r\n\t\tthe SECC project covering its state machine and response messages</li>\r\n\t<li>\r\n\t\ta shared project with common classes used by both entities</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h3>\r\n\tCredits</h3>\r\n<p>The code of the RISE V2G project has its origin in the research project&nbsp;<a href=\"http://izeus.kit.edu/\" target=\"_blank\">iZEUS</a>, funded by the Federal Ministry for Economic Affairs and Energy and conducted at the Karlsruhe Institute of Technology, Germany.<br />\r\n\tThe first prototype of an&nbsp;<a href=\"http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=55366\" target=\"_blank\">ISO/IEC 15118-2</a>&nbsp;implementation has been realised by the RISE V2G project lead within the course of that research project at the Institute of Applied Informatics and Formal Description Methods (AFIB). This prototype has since been reworked and further enhanced at <a href=\"http://www.chargepartner.com/en\" target=\"_blank\">Chargepartner GmbH</a>, a software-as-a-service specialist in the e-mobility market.</p>\r\n<p>&nbsp;</p>\r\n<h3>\r\n\tResources</h3>\r\n<p>The code is hosted on the <a href=\"https://github.com/eclipse/risev2g\" target=\"_blank\">GitHub project website</a>.&nbsp;<br />\r\n\tContribute any questions and suggestions to the <a href=\"https://dev.eclipse.org/mailman/listinfo/risev2g-dev\" target=\"_blank\">developers&#39; mailing list</a>.<br />\r\n\tJoin the <a href=\"http://www.eclipse.org/forums/eclipse.risev2g\" target=\"_blank\">community forum</a> for any discussions.<br />\r\n\tView the <a href=\"https://wiki.eclipse.org/RISE_V2G\" target=\"_blank\">getting started guide and further documentation</a> to get you up and running.<br />\r\n\tIf you encounter a bug, <a href=\"https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Risev2g\" target=\"_blank\">file it in Bugzilla</a>.</p>\r\n<p>&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>",
        "id": "iot.risev2g",
        "logo": null,
        "name": "RISE V2G",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.risev2g",
        "website": null
    },
    "iot.smarthome": {
        "description": "<p>The Eclipse SmartHome project is a framework that allows building smart home solutions that have a strong focus on heterogeneous environments, i.e. solutions that deal with the integration of different protocols or standards. Its purpose is to provide a uniform access to devices and information and to facilitate different kinds of interactions with them. This framework consists out of a set of OSGi bundles that can be deployed on an OSGi runtime and which defines OSGi services as extension points.</p>\r\n<p>The stack is meant to be usable on any kind of system that can run an OSGi stack - be it a multi-core server, a residential gateway or a Raspberry Pi.</p>\r\n<p>&nbsp;</p>",
        "id": "iot.smarthome",
        "logo": "https://projects.eclipse.org/sites/default/files/smarthome_1.png",
        "name": "Eclipse SmartHome",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.smarthome",
        "website": "https://www.eclipse.org/smarthome/"
    },
    "iot.tiaki": {
        "description": "<p>The Tiaki library provides Secure Service Discovery features in a command-line interface and SDK for Java (C coming soon - stay tuned!).</p>\r\n<p>In a nutshell, those are the available functionalities:</p>\r\n<ul>\r\n\t<li>\r\n\t\tlist the available service types from a domain name</li>\r\n\t<li>\r\n\t\tlist the available service instances for a given type and domain name</li>\r\n\t<li>\r\n\t\tlookup TLSA and TXT records for a domain name</li>\r\n\t<li>\r\n\t\tverify that a domain name is DNSSEC-enabled</li>\r\n\t<li>\r\n\t\tvalidate the integrity and authenticity of the data using DNSSEC</li>\r\n\t<li>\r\n\t\tuse your preferred DNS Recursive Resolver</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<p>Tiaki&#39;s Secure Service Discovery implementation is based on the IETF DNS-SD (<a href=\"https://tools.ietf.org/html/rfc6763\" target=\"_blank\">RFC 6763</a>) and the IETF DNSSEC (RFCs&nbsp;<a href=\"https://tools.ietf.org/html/rfc4033\" target=\"_blank\">4033</a>,&nbsp;<a href=\"https://tools.ietf.org/html/rfc4034\" target=\"_blank\">4034</a>, and&nbsp;<a href=\"https://tools.ietf.org/html/rfc4035\" target=\"_blank\">4035</a>).</p>\r\n<div>\r\n\tThe library performs the necessary DNS lookups and DNSSEC validation to ensure both the authenticity and integrity of the records.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tIt is available as a Java SDK or a command-line tool - see the <a href=\"https://projects.eclipse.org/projects/iot.tiaki/downloads\">download section</a>.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tFind out more about how Secure Service Discovery works on <a href=\"https://github.com/eclipse/tiaki-java/tree/master/service-discovery-lib\">our github project</a>.</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<div>\r\n\tTiaki stands for &quot;hold in trust, administer for others&quot; in Maori. More info <a href=\"http://maoridictionary.co.nz/search?keywords=tiaki\" target=\"_blank\">here</a>.</div>",
        "id": "iot.tiaki",
        "logo": null,
        "name": "Tiaki",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.tiaki",
        "website": null
    },
    "iot.tinydtls": {
        "description": "<p>tinydtls is a library for Datagram Transport Layer Security (DTLS) covering both the client and the server state machine. It is implemented in C and provides support for the mandatory cipher suites specified in <a href=\"https://tools.ietf.org/html/rfc7252\">CoAP</a>.</p>",
        "id": "iot.tinydtls",
        "logo": null,
        "name": "tinydtls",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.tinydtls",
        "website": null
    },
    "iot.unide": {
        "description": "<p>Eclipse Unide provides a lightweight Production Performance Management Protocol (PPMP)&nbsp;server-client implementations (using JSON,&nbsp;REST and other). The core of the protocol are two interface definitions:</p>\r\n<ul>\r\n\t<li>\r\n\t\tPPMP Measurement Interface: This is a public REST API with the purpose of receiving time series and machine data.</li>\r\n\t<li>\r\n\t\tPPMP Messages Interface: This is a public REST API with the purpose of receiving machine messages.</li>\r\n</ul>",
        "id": "iot.unide",
        "logo": "https://projects.eclipse.org/sites/default/files/icon.png",
        "name": "Unide",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.unide",
        "website": "http://www.eclipse.org/unide"
    },
    "iot.vorto": {
        "description": "<p>The Vorto project comprises of the meta information model, the tool set to create information models, the code generators and the repository to manage existing information models. The meta information model and also the tool set are based on the Eclipse EMF (Eclipse Modeling Framework) framework. <span>EMF is a modeling framework and code generation facility for building tools and other applications based on a structured data model.</span> For more details regarding EMF, please refer to the <a class=\"external-link\" href=\"http://www.eclipse.org/modeling/emf/\" rel=\"nofollow\">Eclipse Modeling Framework Project</a> page. The tool set is realized as an Eclipse plug-in and thus can be integrated into any supported Eclipse platform.</p>\r\n<p><u>Meta Information Model</u></p>\r\n<p><span style=\"color: rgb(0,0,0);\">While information models represent the capabilities of a particular type of device in its entirety, the meta model describes how the information models are structured. Since the overall target of this project is to push standardization of information models it is very important to have a sustainable and flexible meta model which can be used as a basis of the described standardization. In particular this means that the meta model must be compatible to meta models defined for example by EEBus, ETSI and oneM2M. It is also required that the meta model is compatible with the Smart Home Device Template (SDT) which has been specified by HGi and is currently discussed with BBF, ETSI and the OSGi Alliance.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">Function blocks describe the capabilities of a device, exposing properties, operations and events. The function blocks which are essential parts of information models can be re-used for describing arbitrary types of devices sharing the same functionalities. The meta model is technically based on the Eclipse EMF framework&nbsp;which allows the use of other Eclipse components based on EMF, such as <a href=\"http://www.eclipse.org/sirius/\">Eclipse Sirius</a> for graphical modelers or template engines for code generations such as JET or XPand. </span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The IoT tool set textual editor itself uses the <a href=\"http://www.eclipse.org/Xtext/\">Eclipse Xtext Framework</a> to parse the textual information model representation and convert it to an Information EMF Model. The information model code generators can then further process these EMF models.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\"><u>Code Generators</u></span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The code generators allow application developers to comfortably include the described concepts into their applications. For example one code generator allows generating information model based parts of an access layer for Eclipse Smart Home and another generator allows doing this for openHAB or OSGi-DAL. Other examples could be EEBus, ETSI or oneM2M specific implementation parts. An openHAB&nbsp;generator for example would map an information model to items with command types, which is the basis of the openHAB representation for a thing in the IoT world.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The described tool set provides an extension point to include new code generators without major effort. This enables the usage of the information model concept in various environments and device ecosystems. The code generators concept is very general which means that there are no constraints regarding the implementations.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">As mentioned before the device information model is based on EMF which empowers code generators to generate logic written in any language, for example&nbsp;XML, JSON, Lua, Java or C/C++. It leverages template engines such as Java Emitter Templates (JET) or XPand.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\"><u>IoT Tool Set</u></span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The tool provides two options for creating information models based on the described meta-model:</span></p>\r\n<ul>\r\n\t<li>\r\n\t\t<span style=\"color: rgb(0,0,0);\">The first possibility is to do this using a graphical environment that allows doing most of the steps using drag-and-drop mechanisms. This option targets at the group of business users that have no or only a small background regarding programming skills. The created information models can be validated and it is also possible to use the code generators for the creation of solutions.</span></li>\r\n\t<li>\r\n\t\t<span style=\"color: rgb(0,0,0);\">The second possibility is to use a domain specific language (DSL) that has been designed for comfortably creating the information models. The corresponding editors allow syntax highlighting and auto completion. This option targets at the group of developers that have an IT background and are experienced in using programming and scripting languages.</span></li>\r\n</ul>\r\n<p><span style=\"color: rgb(0,0,0);\">In addition, the tool set shall allow for importing existing information models which are for example conform to ETSI, oneM2M or EEBus.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The planned initial features of the tool set include:</span></p>\r\n<ul>\r\n\t<li>\r\n\t\t<span style=\"color: rgb(0,0,0);\">Information Model Language Editor<strong>:&nbsp;</strong>A simple way to describe information models in a declarative way using auto-completion, syntax highlighting, content assistance and model validation. The declarative model is internally converted into an EMF model.</span></li>\r\n\t<li>\r\n\t\t<span style=\"color: rgb(0,0,0);\">Eclipse Project Wizard<strong>:</strong>&nbsp;Easily create an information model project using an Eclipse Project Wizard.&nbsp;</span></li>\r\n</ul>\r\n<p><span style=\"color: rgb(0,0,0);\"><u>The Information Model Repository</u></span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">The information model repository is a server based technology which shall be used as the centralized storage location for information models. During development time the repository allows developers accessing the standardized information models for integrating them into applications (e.g. by using the above described code generators).</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">It is comprised of:</span></p>\r\n<ul>\r\n\t<li>\r\n\t\t<span style=\"line-height: 1.42857;color: rgb(0,0,0);\">Resource and version management using e.g. Git or CDO.</span></li>\r\n\t<li>\r\n\t\t<span style=\"line-height: 1.42857;color: rgb(0,0,0);\">Query layer to query information models by different search criteria.</span></li>\r\n\t<li>\r\n\t\t<span style=\"line-height: 1.42857;color: rgb(0,0,0);\">Dependency management of information models.</span></li>\r\n\t<li>\r\n\t\t<span style=\"line-height: 1.42857;color: rgb(0,0,0);\">Web browser interface.</span></li>\r\n\t<li>\r\n\t\t<span style=\"line-height: 1.42857;color: rgb(0,0,0);\">IDE Integration.</span></li>\r\n</ul>\r\n<p><span style=\"color: rgb(0,0,0);\">When version 1.0 of the repository is released it shall be hosted by the Eclipse Foundation to initialize the standardization process.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\"><u>Example</u></span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">Let&#39;s assume Vendor A creates a new Z-Wave smoke detector which can measure the temperature, return the battery status and also fire an alarm event in case of fire. Using the IoT tool set, vendor A creates a corresponding information model which describes the three functionalities. After creating the information model vendor A publishes the model to the Information Model Repository. Now user B who bought such a smoke detector wants to include it into his openHAB environment. Using the IoT tool set he can browse the repository to find the information model created by Vendor A. After downloading it he could create the openHAB representation of the device using a specific code generator. In a last step he would complete this representation by adding required Z-Wave configurations.</span></p>\r\n<p><span style=\"color: rgb(0,0,0);\">In another scenario user C wants to access the smoke detector using an OSGi device abstraction layer. He also downloads the information model using the IoT tool set and creates an implementation skeleton using another OSGi specific code generator. Within the created skeleton he would then add his specific code.</span></p>",
        "id": "iot.vorto",
        "logo": null,
        "name": "Vorto",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.vorto",
        "website": "http://www.eclipse.org/vorto"
    },
    "iot.wakaama": {
        "description": "<p>Wakaama provides APIs for a server application to send commands to registered LWM2M Clients. On client applications, Wakaama checks received commands for syntax and access rights and then dispatches them to the relevant objects.</p>",
        "id": "iot.wakaama",
        "logo": null,
        "name": "Wakaama",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/technology.wakaama",
        "website": null
    },
    "iot.whiskers": {
        "description": "<p>Whiskers is an <a href=\"https://en.wikipedia.org/wiki/SensorThings_API\">OGC SensorThings API</a> framework consisting of a JavaScript client and a light-weight server for IoT gateways (e.g., Raspberry Pi). The SensorThings API is an OGC (Open Geospatial Consortium) standard that allows IoT (Internet of Things) devices and their data to be connected; a major goal is to foster a healthy and open IoT ecosystem, as opposed to one dominated by proprietary information silos.</p>\r\n<p>JavaScript is ubiquitous, powering client-side web applications and server-side services alike. The availability of an open source client library is an important step in the adoption of the OGC SensorThings standard, as it makes development quicker and easier.</p>\r\n<p>In addition the a client library, Whiskers will also have a SensorThings server module for IoT gateways, such as Raspberry Pi. Developers will be able to deploy and configure IoT gateways, make them SensorThings API-compliant, and connect with spatial data servers around the world that implement the full array of <a href=\"http://www.opengeospatial.org/ogc/markets-technologies/swe\">OGC Sensor Web Enablement (SWE) standards</a>.</p>\r\n<p>Whiskers aims to make SensorThings development easy for the large and growing world of IoT developers.</p>",
        "id": "iot.whiskers",
        "logo": null,
        "name": "Whiskers",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/iot.whiskers",
        "website": null
    },
    "rt.ecf": {
        "description": "<p><a href=\"http://www.eclipse.org/ecf\">ECF</a> provides frameworks for messaging and communications. We fully implement the <a href=\"https://wiki.eclipse.org/ECF#OSGi_Remote_Services\">OSGi Remote Services</a>&nbsp;(RS) and Remote Service Admin (RSA) specifications.</p>",
        "id": "rt.ecf",
        "logo": "https://projects.eclipse.org/sites/default/files/logo128x37.png",
        "name": "Eclipse Communication Framework",
        "provisioned": true,
        "state": "Regular",
        "url": "https://projects.eclipse.org/projects/rt.ecf",
        "website": "http://www.eclipse.org/ecf"
    },
    "tools.mtj": {
        "description": "<p><span>Mobile Tools for Java&trade; project creates tools and frameworks to extend the Eclipse platform to support embedded and mobile device Java application development.</span></p>\r\n<!--break-->\r\n<h4>\r\n\tNews</h4>\r\n<ul>\r\n\t<li>\r\n\t\tSeptember 15, 2015,&nbsp;<strong>Mobile Tools for Java&trade;&nbsp;2.0.1 is released.</strong><br />\r\n\t\t<br />\r\n\t\t<div>\r\n\t\t\tMobile Tools for Java&trade; (MTJ) 2.0.1 release is focused on bug fixes and support of latest Eclipse Mars.</div>\r\n\t\t<div>\r\n\t\t\tThe scope of MTJ 2.0.1 is listed below:</div>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tMigration to Eclipse Mars</li>\r\n\t\t\t<li>\r\n\t\t\t\tBetter Javadocs detections for libraries that represent the same logical API but correspond to different API versions</li>\r\n\t\t\t<li>\r\n\t\t\t\tBug fixes</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\tNovember 14, 2014,&nbsp;<strong><span>Mobile Tools for Java&trade;&nbsp;2.0 is released.</span></strong><br />\r\n\t\t<div>\r\n\t\t\t<p><span>Mobile Tools for Java&trade; (MTJ) 2.0 release is making MTJ plugin IoT ready by supporting Java&trade; ME 8 platform. Java&trade; ME 8 is the major update of the Java&trade; ME technology as a modern embedded software platform, purpose-built as a foundation for new services in the Internet of Things (IoT). MTJ 2.0 is based on Eclipse Luna and provides a support for CLDC 1.8 configuration (<a href=\"https://jcp.org/en/jsr/detail?id=360\">JSR 360</a>), MEEP 8.0 profile (<a href=\"https://jcp.org/en/jsr/detail?id=361\">JSR 361</a>) and better IMP-NG profile (<a href=\"https://jcp.org/en/jsr/detail?id=228\">JSR 228</a>) support.</span></p>\r\n\t\t\t<p><span>Other improvements in this release includes new extensible Code Validation Builder that provides an ability to perform pre-compilation analysis and generates warnings by 3rd party plugins created on top of MTJ, support for Java&trade; ME APIs javadocs in zip archives and a lot of bug fixes.&nbsp;</span></p>\r\n\t\t</div>\r\n\t</li>\r\n</ul>\r\n<p>&nbsp;</p>",
        "id": "tools.mtj",
        "logo": null,
        "name": "Mobile Tools for Java",
        "provisioned": true,
        "state": "Regular",
        "url": "https://projects.eclipse.org/projects/tools.mtj",
        "website": "http://www.eclipse.org/mtj/"
    },
    "tools.titan": {
        "description": "<p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 14px;\">Titan is a TTCN-3 compilation and execution environment with an &nbsp;Eclipse-based IDE.&nbsp;</span><span style=\"font-family: arial, helvetica, sans-serif; font-size: 14px;\">The user of the tool can develop test cases, test execution logic and build the executable test suite for several platforms.</span></p>",
        "id": "tools.titan",
        "logo": "https://projects.eclipse.org/sites/default/files/Symbol_200.png",
        "name": "Eclipse Titan",
        "provisioned": true,
        "state": "Incubating",
        "url": "https://projects.eclipse.org/projects/tools.titan",
        "website": null
    }
}